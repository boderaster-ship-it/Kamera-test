<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Dual-Cam Recorder ‚Ä¢ 50/50</title>
  <style>
    :root { --gap: 10px; }
    * { box-sizing: border-box; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    html, body { height: 100%; }
    body {
      margin: 0; padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      background: #0b0f14; color: #e9eef5;
      overscroll-behavior: none; /* block Pull-to-refresh/Edge-Swipe Scroll */
      -webkit-touch-callout: none; -webkit-user-select: none; user-select: none;
    }
    h1 { font-size: 16px; margin: 0 0 10px; opacity: .9; }
    .toolbar {
      display: grid; grid-template-columns: repeat(4,1fr); gap: var(--gap);
      position: sticky; top: env(safe-area-inset-top); z-index: 3;
    }
    button {
      padding: 14px 12px; border-radius: 12px; border: 1px solid #2b3442; background: #1b2330; color: #e9eef5;
      font-size: 15px; touch-action: manipulation;
    }
    button:disabled { opacity: .5; }
    #stage {
      position: relative; width: 100%; aspect-ratio: 16/9;
      background: #000; border: 1px solid #2b3442; border-radius: 14px; overflow: hidden; margin-top: 12px;
    }
    canvas { width: 100%; height: 100%; display: block; }
    .hidden {
      position: absolute; inset: 0; width: 1px; height: 1px; opacity: 0; pointer-events: none;
    }
    #playback { width: 100%; margin-top: 12px; border-radius: 12px; display:none; }
    .links { margin-top: 10px; display:flex; gap:10px; flex-wrap: wrap; }
    a.dl { color: #9cd2ff; text-decoration: none; border: 1px dashed #2b3442; padding: 6px 10px; border-radius: 8px; }
    .note { font-size: 12px; opacity: .8; margin-top: 8px; line-height: 1.4; }
    /* ‚ÄûBildschirmrand blocken‚Äú ‚Äì fange Gesten an den R√§ndern ab */
    .edge-guard {
      position: fixed; inset: 0; pointer-events: none; z-index: 5;
    }
    .edge-guard > div {
      position: absolute; pointer-events: auto; /* f√§ngt Swipes ab */
      background: transparent;
    }
    .edge-guard .top    { left: 0; right: 0; top: 0; height: env(safe-area-inset-top, 16px); }
    .edge-guard .bottom { left: 0; right: 0; bottom: 0; height: calc(env(safe-area-inset-bottom, 16px) + 6px); }
    .edge-guard .left   { left: 0; top: 0; bottom: 0; width: 6px; }
    .edge-guard .right  { right: 0; top: 0; bottom: 0; width: 6px; }
  </style>
</head>
<body>
  <h1>Dual-Cam Recorder (Front + Back ‚Ä¢ 50/50)</h1>

  <div class="toolbar">
    <button id="startBtn">‚ñ∂Ô∏è Start</button>
    <button id="pauseBtn" disabled>‚è∏Ô∏è Pause</button>
    <button id="resumeBtn" disabled>‚èØÔ∏è Play</button>
    <button id="stopBtn" disabled>‚èπÔ∏è Stop = Speichern</button>
  </div>

  <div id="stage">
    <canvas id="mix"></canvas>
    <div class="hidden">
      <video id="vFront" playsinline muted></video>
      <video id="vBack"  playsinline muted></video>
    </div>
  </div>

  <video id="playback" controls></video>
  <div class="links" id="links"></div>

  <!-- Edge-Guards, um iOS-Randswipes m√∂glichst zu neutralisieren -->
  <div class="edge-guard" aria-hidden="true">
    <div class="top"></div><div class="bottom"></div><div class="left"></div><div class="right"></div>
  </div>

  <p class="note" id="info"></p>

  <script>
    // ====== Elemente
    const startBtn  = document.getElementById('startBtn');
    const pauseBtn  = document.getElementById('pauseBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const stopBtn   = document.getElementById('stopBtn');

    const vFront = document.getElementById('vFront');
    const vBack  = document.getElementById('vBack');
    const canvas = document.getElementById('mix');
    const ctx    = canvas.getContext('2d');
    const playback = document.getElementById('playback');
    const linksBox = document.getElementById('links');
    const info     = document.getElementById('info');

    // ====== State
    let frontStream = null, backStream = null, recordingStream = null;
    let drawRAF = null, rec = null, recordedBlobs = [];
    let wakeLock = null;

    // ====== Utility
    const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

    function setButtons(state) {
      const s = { start:false, pause:true, resume:true, stop:true };
      if (state === 'idle')       Object.assign(s,{start:false, pause:true,  resume:true,  stop:true});
      if (state === 'recording')  Object.assign(s,{start:true,  pause:false, resume:true,  stop:false});
      if (state === 'paused')     Object.assign(s,{start:true,  pause:true,  resume:false, stop:false});
      if (state === 'stopped')    Object.assign(s,{start:false, pause:true,  resume:true,  stop:true});
      startBtn.disabled  = s.start; pauseBtn.disabled = s.pause; resumeBtn.disabled = s.resume; stopBtn.disabled = s.stop;
    }

    function note(msg){ info.textContent = msg; }

    function setCanvasSize(){
      // Hochaufl√∂send, 16:9
      canvas.width = 1920; canvas.height = 1080;
    }

    function drawCover(dctx, video, dx, dy, dw, dh) {
      const vw = video.videoWidth|0, vh = video.videoHeight|0;
      if (!vw || !vh) return;
      const vr = vw/vh, dr = dw/dh;
      let sx,sy,sw,sh;
      if (vr > dr) { sh = vh; sw = vh*dr; sx = (vw-sw)/2; sy = 0; }
      else { sw = vw; sh = vw/dr; sx = 0; sy = (vh-sh)/2; }
      dctx.drawImage(video, sx,sy,sw,sh, dx,dy,dw,dh);
    }

    function startDrawLoop(){
      cancelAnimationFrame(drawRAF);
      const loop = () => {
        const W=canvas.width, H=canvas.height, half=Math.floor(W/2);
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
        drawCover(ctx, vFront, 0, 0, half, H);
        drawCover(ctx, vBack,  half, 0, W-half, H);
        ctx.fillStyle='rgba(255,255,255,.12)'; ctx.fillRect(half-1,0,2,H);
        drawRAF = requestAnimationFrame(loop);
      };
      loop();
    }

    function stopDrawLoop(){ cancelAnimationFrame(drawRAF); drawRAF=null; }

    async function lockWake(){
      try {
        if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen');
      } catch {}
    }
    function releaseWake(){ try{ wakeLock && wakeLock.release(); }catch{} wakeLock=null; }

    async function pickTwoCameras() {
      // Versuche explizit zwei verschiedene deviceId zu holen (besser als facingMode auf iOS).
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === 'videoinput');

      // Heuristik: w√§hle ‚Äûuser‚Äú und ‚Äûenvironment‚Äú, falls vorhanden
      let userCam = cams.find(c => /front|user/i.test(c.label)) || cams[0];
      let envCam  = cams.find(c => /back|rear|environment/i.test(c.label)) || cams[1] || cams[0];

      // Starte R√ºckkamera (mit Audio) und Frontkamera (ohne Audio)
      // iOS kann parallelen Zugriff evtl. verweigern -> wir versuchen trotzdem beides nacheinander.
      const tryBack = navigator.mediaDevices.getUserMedia({
        video: envCam ? { deviceId: { exact: envCam.deviceId } } : { facingMode: { ideal:'environment' } },
        audio: true
      });

      const tryFront = navigator.mediaDevices.getUserMedia({
        video: userCam ? { deviceId: { exact: userCam.deviceId } } : { facingMode: { ideal:'user' } },
        audio: false
      });

      // WICHTIG: nacheinander awaiten, damit iOS die Reservationen hintereinander akzeptiert
      const back = await tryBack;
      const front = await tryFront;

      return { back, front };
    }

    async function initStreams() {
      // Manche iOS-Ger√§te erlauben KEINE zwei Kameras parallel per Web-API (Systemlimit). Wir versuchen alle Wege:
      try {
        // 1) Direkt via deviceId (beste Chance)
        const { back, front } = await pickTwoCameras();
        backStream = back; frontStream = front;
      } catch (e1) {
        // 2) Fallback: environment + user via facingMode
        try {
          backStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { exact:'environment'} }, audio:true });
          frontStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { exact:'user'} }, audio:false });
        } catch (e2) {
          // 3) Letzter Versuch: environment + user ohne exact
          backStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio:true });
          frontStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio:false });
        }
      }

      vFront.srcObject = frontStream;
      vBack.srcObject  = backStream;
      await Promise.race([vFront.play().catch(()=>{}), new Promise(r=>setTimeout(r, 100))]);
      await Promise.race([vBack.play().catch(()=>{}), new Promise(r=>setTimeout(r, 100))]);

      // Wenn nur eine Kamera tats√§chlich l√§uft, melde das im UI.
      const fOK = frontStream && frontStream.getVideoTracks().some(t=>t.readyState==='live');
      const bOK = backStream  && backStream.getVideoTracks().some(t=>t.readyState==='live');
      if (!fOK || !bOK) {
        note('Hinweis: Dein Ger√§t/Browser erlaubt vermutlich keinen gleichzeitigen Zugriff auf Front- und R√ºckkamera im Web. Es wird die verf√ºgbare Kamera genutzt.');
      } else {
        note('');
      }
    }

    function buildRecordingStream() {
      const mixedVideo = canvas.captureStream(30);
      const out = new MediaStream();
      mixedVideo.getVideoTracks().forEach(t => out.addTrack(t));
      const mic = backStream && backStream.getAudioTracks()[0];
      if (mic) out.addTrack(mic);
      return out;
    }

    function chooseMimeType() {
      const list = [
        'video/mp4;codecs=h264,aac',
        'video/mp4',
        'video/webm;codecs=vp9,opus',
        'video/webm;codecs=vp8,opus',
        'video/webm'
      ];
      for (const t of list) if (MediaRecorder.isTypeSupported?.(t)) return t;
      return '';
    }

    function resetOutput(){
      playback.pause(); playback.removeAttribute('src'); playback.style.display='none';
      linksBox.innerHTML=''; recordedBlobs.length = 0;
    }

    function offerShareToPhotos(blob){
      // iOS: Teile das Video ‚Äì im Share Sheet gibt es ‚ÄûVideo sichern‚Äú in die Fotos-App.
      const fileName = `DualCam_${new Date().toISOString().replace(/[:.]/g,'-')}.mp4`;
      const file = new File([blob], fileName, { type: blob.type || 'video/mp4' });

      if (navigator.canShare?.({ files:[file] }) && navigator.share) {
        navigator.share({ files:[file], title:'Dual-Cam Aufnahme', text:'Gespeicherte Aufnahme' })
          .catch(()=>{ /* abgebrochen */ });
      } else {
        // Fallback: Download-Link + Vorschau; in iOS Share √ºber das Video -> ‚ÄûVideo sichern‚Äú
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = fileName; a.className='dl';
        a.textContent = 'üì• Video laden / teilen';
        linksBox.appendChild(a);
        playback.src = url; playback.style.display='block';
      }
    }

    function cleanupStreams(){
      [frontStream, backStream, recordingStream].forEach(s => s && s.getTracks().forEach(t=>t.stop()));
      frontStream = backStream = recordingStream = null;
    }

    // ====== Buttons
    startBtn.addEventListener('click', async () => {
      try {
        setButtons('idle');
        resetOutput();
        setCanvasSize();
        await lockWake();

        // versuche Vollbild (auf iOS nur via <video> sicher m√∂glich ‚Äì hier nicht hart erzwungen)
        // document.documentElement.requestFullscreen?.().catch(()=>{});

        await initStreams();
        startDrawLoop();

        recordingStream = buildRecordingStream();
        const mimeType = chooseMimeType();
        try {
          rec = new MediaRecorder(recordingStream, mimeType ? { mimeType } : {});
        } catch (e) {
          alert('MediaRecorder konnte nicht initialisiert werden: ' + (e?.message||e));
          stopDrawLoop(); cleanupStreams(); releaseWake(); return;
        }

        rec.ondataavailable = (e)=>{ if (e.data && e.data.size) recordedBlobs.push(e.data); };
        rec.onstop = () => {
          const type = rec.mimeType || 'video/mp4';
          const blob = new Blob(recordedBlobs, { type });
          // ‚ûú Sofort in Fotos teilen/speichern:
          offerShareToPhotos(blob);

          cleanupStreams();
          stopDrawLoop();
          setButtons('stopped');
          releaseWake();
        };

        rec.start(1000);
        setButtons('recording');
      } catch (err) {
        alert('Fehler beim Starten: ' + (err?.message || err));
        cleanupStreams(); stopDrawLoop(); releaseWake(); setButtons('stopped');
      }
    });

    pauseBtn.addEventListener('click', ()=>{ if (rec?.state==='recording') { try{ rec.pause(); setButtons('paused'); }catch{} }});
    resumeBtn.addEventListener('click', ()=>{ if (rec?.state==='paused')    { try{ rec.resume(); setButtons('recording'); }catch{} }});
    stopBtn.addEventListener('click',   ()=>{ if (rec && rec.state!=='inactive') { try{ rec.stop(); }catch{} }});

    // Blocke Doppeltipp-Zoom/Edge-Gesten m√∂glichst
    ['touchstart','touchmove','gesturestart','dblclick'].forEach(ev=>{
      window.addEventListener(ev, e => { e.preventDefault(); }, { passive:false });
    });

    // Sicherheitsnetz beim Verlassen
    window.addEventListener('pagehide', ()=>{ try{ if (rec && rec.state!=='inactive') rec.stop(); }catch{} cleanupStreams(); stopDrawLoop(); releaseWake(); });
  </script>
</body>
</html>
