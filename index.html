<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>iPhone Dual-Cam Recorder (50/50)</title>
  <style>
    :root { --gap: 10px; }
    * { box-sizing: border-box; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    html, body { height: 100%; }
    body {
      margin: 0;
      padding: env(safe-area-inset-top) env(safe-area-inset-right)
               env(safe-area-inset-bottom) env(safe-area-inset-left);
      background: #0b0f14; color: #e9eef5;
      overscroll-behavior: none;
      -webkit-touch-callout: none; -webkit-user-select: none; user-select: none;
      touch-action: manipulation; /* kein Doppeltipp-Zoom */
    }
    h1 { font-size: 16px; margin: 0 0 8px; opacity: .95; }
    .toolbar {
      display: grid; grid-template-columns: repeat(4,1fr); gap: var(--gap);
      position: sticky; top: env(safe-area-inset-top); z-index: 3;
    }
    button {
      padding: 14px 12px; border-radius: 12px;
      border: 1px solid #2b3442; background: #1b2330; color: #e9eef5;
      font-size: 15px; touch-action: manipulation;
    }
    button:disabled { opacity: .5; }
    #stage {
      position: relative; width: 100%; aspect-ratio: 16/9;
      background: #000; border: 1px solid #2b3442; border-radius: 14px;
      overflow: hidden; margin-top: 12px;
    }
    canvas { width: 100%; height: 100%; display: block; }
    .hidden {
      position: absolute; inset: 0; width: 1px; height: 1px; opacity: 0; pointer-events: none;
    }
    #playback { width: 100%; margin-top: 12px; border-radius: 12px; display:none; }
    .links { margin-top: 10px; display:flex; gap:10px; flex-wrap: wrap; }
    a.dl { color: #9cd2ff; text-decoration: none; border: 1px dashed #2b3442; padding: 6px 10px; border-radius: 8px; }
    .note { font-size: 12px; opacity: .85; margin-top: 8px; line-height: 1.35; min-height: 1.35em; }
    /* Edge-Guards: fangen Randswipes, ohne Klicks zu blocken */
    .edge-guard { position: fixed; inset: 0; pointer-events: none; z-index: 5; }
    .edge-guard > div { position: absolute; pointer-events: auto; background: transparent; }
    .edge-guard .top    { left:0; right:0; top:0;    height: max(env(safe-area-inset-top), 8px); }
    .edge-guard .bottom { left:0; right:0; bottom:0; height: calc(max(env(safe-area-inset-bottom), 8px) + 6px); }
    .edge-guard .left   { left:0; top:0; bottom:0;   width: 6px; }
    .edge-guard .right  { right:0; top:0; bottom:0;  width: 6px; }
  </style>
</head>
<body>
  <h1>Dual-Cam Recorder (Front + Back ‚Ä¢ 50/50)</h1>

  <div class="toolbar">
    <button id="startBtn">‚ñ∂Ô∏è Start</button>
    <button id="pauseBtn" disabled>‚è∏Ô∏è Pause</button>
    <button id="resumeBtn" disabled>‚èØÔ∏è Play</button>
    <button id="stopBtn" disabled>‚èπÔ∏è Stop = Speichern</button>
  </div>

  <div id="stage">
    <canvas id="mix"></canvas>
    <div class="hidden">
      <video id="vFront" playsinline muted></video>
      <video id="vBack"  playsinline muted></video>
    </div>
  </div>

  <video id="playback" controls></video>
  <div class="links" id="links"></div>
  <p class="note" id="info"></p>

  <!-- Edge Guards -->
  <div class="edge-guard" aria-hidden="true">
    <div class="top"></div><div class="bottom"></div><div class="left"></div><div class="right"></div>
  </div>

  <script>
    /* ========= Elemente ========= */
    const startBtn  = document.getElementById('startBtn');
    const pauseBtn  = document.getElementById('pauseBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const stopBtn   = document.getElementById('stopBtn');

    const vFront = document.getElementById('vFront');
    const vBack  = document.getElementById('vBack');
    const canvas = document.getElementById('mix');
    const ctx    = canvas.getContext('2d');
    const playback = document.getElementById('playback');
    const linksBox = document.getElementById('links');
    const info     = document.getElementById('info');

    /* ========= State ========= */
    let frontStream = null, backStream = null, recordingStream = null;
    let drawRAF = null, rec = null, recordedBlobs = [];
    let wakeLock = null;

    /* ========= Helpers ========= */
    function note(msg){ info.textContent = msg || ''; }

    function setButtons(state) {
      const disabled = { start:false, pause:true, resume:true, stop:true };
      if (state === 'idle')      Object.assign(disabled,{ start:false, pause:true,  resume:true,  stop:true });
      if (state === 'recording') Object.assign(disabled,{ start:true,  pause:false, resume:true,  stop:false });
      if (state === 'paused')    Object.assign(disabled,{ start:true,  pause:true,  resume:false, stop:false });
      if (state === 'stopped')   Object.assign(disabled,{ start:false, pause:true,  resume:true,  stop:true });
      startBtn.disabled  = disabled.start;
      pauseBtn.disabled  = disabled.pause;
      resumeBtn.disabled = disabled.resume;
      stopBtn.disabled   = disabled.stop;
    }

    function setCanvasSize(){ canvas.width = 1920; canvas.height = 1080; }

    function drawCover(dctx, video, dx, dy, dw, dh) {
      const vw = video.videoWidth|0, vh = video.videoHeight|0;
      if (!vw || !vh) return;
      const vr = vw/vh, dr = dw/dh;
      let sx,sy,sw,sh;
      if (vr > dr) { sh = vh; sw = vh*dr; sx = (vw-sw)/2; sy = 0; }
      else { sw = vw; sh = vw/dr; sx = 0; sy = (vh-sh)/2; }
      dctx.drawImage(video, sx,sy,sw,sh, dx,dy,dw,dh);
    }

    function startDrawLoop(){
      cancelAnimationFrame(drawRAF);
      const loop = () => {
        const W=canvas.width, H=canvas.height, half=W>>1;
        ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);
        drawCover(ctx, vFront, 0, 0, half, H);
        drawCover(ctx, vBack,  half, 0, W-half, H);
        ctx.fillStyle='rgba(255,255,255,.12)'; ctx.fillRect(half-1, 0, 2, H);
        drawRAF = requestAnimationFrame(loop);
      };
      loop();
    }
    function stopDrawLoop(){ cancelAnimationFrame(drawRAF); drawRAF=null; }

    async function lockWake(){ try { if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen'); } catch {} }
    function releaseWake(){ try{ wakeLock && wakeLock.release(); }catch{} wakeLock=null; }

    function chooseMimeType() {
      const list = [
        'video/mp4;codecs=h264,aac',
        'video/mp4',
        'video/webm;codecs=vp9,opus',
        'video/webm;codecs=vp8,opus',
        'video/webm'
      ];
      for (const t of list) if (MediaRecorder.isTypeSupported?.(t)) return t;
      return '';
    }

    function resetOutput(){
      playback.pause(); playback.removeAttribute('src'); playback.style.display='none';
      linksBox.innerHTML=''; recordedBlobs.length=0;
    }

    function cleanupStreams(){
      [frontStream, backStream, recordingStream].forEach(s=>s && s.getTracks().forEach(t=>t.stop()));
      frontStream = backStream = recordingStream = null;
    }

    function buildRecordingStream() {
      const mixedVideo = canvas.captureStream(30);
      const out = new MediaStream();
      mixedVideo.getVideoTracks().forEach(t => out.addTrack(t));
      const mic = backStream?.getAudioTracks?.()[0];
      if (mic) out.addTrack(mic);
      return out;
    }

    function offerShareToPhotos(blob){
      const fileName = `DualCam_${new Date().toISOString().replace(/[:.]/g,'-')}.mp4`;
      const file = new File([blob], fileName, { type: blob.type || 'video/mp4' });
      if (navigator.canShare?.({ files:[file] }) && navigator.share) {
        navigator.share({ files:[file], title:'Dual-Cam Aufnahme', text:'Gespeicherte Aufnahme' })
          .catch(()=>{ /* Abbruch ignorieren */ });
      } else {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = fileName; a.className='dl';
        a.textContent = 'üì• Video laden / teilen';
        linksBox.appendChild(a);
        playback.src = url; playback.style.display='block';
      }
    }

    /* ========= Kamera-Init in zwei Phasen (fix f√ºr ‚Äûzweimal Front‚Äú) =========
       1) Erst R√ºckkamera √∂ffnen (Audio + Video) -> Berechtigung -> enumerateDevices liefert Labels.
       2) Danach explizit eine *andere* Kamera (Front) via deviceId √∂ffnen.
       F√§llt die zweite Kamera weg => klarer Hinweis. */
    async function openBackThenFront() {
      // 1) R√ºckkamera mit Audio
      backStream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal:'environment' } }, audio: true
      });
      vBack.srcObject = backStream;
      await vBack.play().catch(()=>{});

      // 2) Jetzt Ger√§te mit Labels erfragen
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === 'videoinput');

      // bevorzugt Kamera, die NICHT dieselbe deviceId wie backStream hat
      const backId = backStream.getVideoTracks()[0]?.getSettings?.().deviceId;
      // Front-Kandidaten: label enth√§lt "front"/"user", sonst beliebige andere als backId
      let frontDevice = cams.find(c => /front|user/i.test(c.label) && c.deviceId !== backId)
                      || cams.find(c => c.deviceId !== backId)
                      || cams[0];

      // 3) Front ohne Audio √∂ffnen; wenn deviceId scheitert -> facingMode Fallback
      try {
        if (frontDevice) {
          frontStream = await navigator.mediaDevices.getUserMedia({
            video: { deviceId: { exact: frontDevice.deviceId } }, audio: false
          });
        } else {
          throw new Error('No distinct front device found');
        }
      } catch {
        // Fallback (kann auf iOS trotzdem scheitern, wenn Parallelzugriff gesperrt ist)
        frontStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal:'user' } }, audio: false
        });
      }

      vFront.srcObject = frontStream;
      await vFront.play().catch(()=>{});

      // Pr√ºfen ob beide wirklich ‚Äûlive‚Äú sind
      const fOK = frontStream?.getVideoTracks?.()[0]?.readyState === 'live';
      const bOK = backStream?.getVideoTracks?.()[0]?.readyState === 'live';
      if (!fOK || !bOK) {
        note('Hinweis: iOS Safari auf deinem Ger√§t erlaubt parallel nur eine Kamera. Es wird die verf√ºgbare genutzt.');
      } else {
        note('');
      }
    }

    /* ========= Button-Logik ========= */
    setButtons('idle');

    startBtn.addEventListener('click', async () => {
      try {
        setButtons('idle');
        resetOutput();
        setCanvasSize();
        await lockWake();

        // WICHTIG: keine globalen touchstart-prevents, damit Buttons funktionieren
        await openBackThenFront();    // <‚Äî Fix f√ºr ‚Äûzweimal Front‚Äú

        startDrawLoop();

        recordingStream = buildRecordingStream();
        const mimeType = chooseMimeType();
        try {
          rec = new MediaRecorder(recordingStream, mimeType ? { mimeType } : {});
        } catch (e) {
          alert('MediaRecorder nicht verf√ºgbar: ' + (e?.message||e));
          stopDrawLoop(); cleanupStreams(); releaseWake(); return;
        }

        rec.ondataavailable = (e)=>{ if (e.data && e.data.size) recordedBlobs.push(e.data); };
        rec.onstop = () => {
          const type = rec.mimeType || 'video/mp4';
          const blob = new Blob(recordedBlobs, { type });
          offerShareToPhotos(blob);   // -> Fotos (√ºber ‚ÄûTeilen‚Äú > ‚ÄûVideo sichern‚Äú)
          cleanupStreams();
          stopDrawLoop();
          setButtons('stopped');
          releaseWake();
        };

        rec.start(1000);
        setButtons('recording');
      } catch (err) {
        alert('Start fehlgeschlagen: ' + (err?.message || err));
        cleanupStreams(); stopDrawLoop(); releaseWake(); setButtons('stopped');
      }
    }, { passive: true });

    pauseBtn.addEventListener('click', () => {
      try {
        if (rec && rec.state === 'recording' && 'pause' in rec) {
          rec.pause(); setButtons('paused');
        }
      } catch {}
    }, { passive: true });

    resumeBtn.addEventListener('click', () => {
      try {
        if (rec && rec.state === 'paused' && 'resume' in rec) {
          rec.resume(); setButtons('recording');
        }
      } catch {}
    }, { passive: true });

    stopBtn.addEventListener('click', () => {
      try {
        if (rec && rec.state !== 'inactive') rec.stop();
      } catch {}
    }, { passive: true });

    // Edge-Guards: nur Gesten am Rand abfangen (Buttons bleiben klickbar)
    ['touchmove','gesturestart'].forEach(ev=>{
      document.querySelector('.edge-guard')?.addEventListener(ev, e => { e.preventDefault(); }, { passive:false });
    });

    // Sicherheitsnetz bei Verlassen
    window.addEventListener('pagehide', () => {
      try { if (rec && rec.state!=='inactive') rec.stop(); } catch {}
      cleanupStreams(); stopDrawLoop(); releaseWake();
    });
  </script>
</body>
</html>
